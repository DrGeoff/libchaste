// CamIO 2: array.c
// Copyright (C) 2013: Matthew P. Grosvenor (matthew.grosvenor@cl.cam.ac.uk) 
// Licensed under BSD 3 Clause, please see LICENSE for more details. 

#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#include "array_std_int.h"
//#include "../log/log.h"

#include "../types/types.h"
#include "../utils/util.h"



/*Resize the array*/
static void _resize(ch_array_##TYPE##_t* this, ch_word new_size)
{
    this->_array_backing = (TYPE*)realloc(this->_array_backing, new_size * sizeof(TYPE));
    if(!this->_array_backing){
        prTYPEf("Could not allocate memory for backing store\n");
        return;
    }

    if(new_size < this->_array_backing_size){
        this->end = this->_array_backing + new_size;
        this->last = this->end - 1;
        this->_array_backing_count = new_size;
        this->count = this->_array_backing_count;
    }

    this->_array_backing_size = new_size;
    this->size = new_size; /* Update the public size*/

}

/*Take an index an fix it so that negative indexs are legal */
static inline ch_word range_fix(ch_array_##TYPE##_t* this, ch_word idx)
{
    idx = idx < 0 ? idx + this->_array_backing_size : idx;

    if(idx >= 0 && idx < this->_array_backing_count && idx < this->_array_backing_size){
        return idx;
    }

    prTYPEf("Index (%li) is out of the valid range [%li,%li]", idx, -1 * this->_array_backing_size, this->_array_backing_size - 1 );
    return -1;

}


/*Return the element at a given offset, with bounds checking*/
static TYPE* _off(ch_array_##TYPE##_t* this, ch_word idx)
{

    idx = range_fix(this, idx);
    if(idx >= 0){
        return &this->_array_backing[idx];
    }

    return NULL;

}


static TYPE* _forward(ch_array_##TYPE##_t* this, TYPE* ptr, ch_word amount)
{
    if(ptr + amount <= this->end){
        return ptr += amount;
    }

    return ptr;
}

static TYPE* _back(ch_array_##TYPE##_t* this, TYPE* ptr, ch_word amount)
{
    if(ptr - amount >= this->first){
        return ptr -= amount;
    }

    return ptr;
}



static TYPE* _next(ch_array_##TYPE##_t* this, TYPE* ptr)
{
    return _forward(this, ptr, 1);
}

static TYPE* _prev(ch_array_##TYPE##_t* this, TYPE* ptr)
{
    return _back(this, ptr, 1);
}



/*find the given value using the comparitor function*/
static TYPE* _find(ch_array_##TYPE##_t* this, TYPE* begin, TYPE* end, TYPE value)
{
    for(TYPE* it = begin; it != end; it++){
        if(this->_cmp(*it,value) == 0 ){
            return it;
        }
    }

    return NULL;
}

/*sort TYPEo order given the comparitor function*/
static void _sort(ch_array_##TYPE##_t* this)
{
    (void)this;
}

/*sort TYPEo reverse order given the comparitor function*/
static void _sort_reverse(ch_array_##TYPE##_t* this)
{
    (void)this;
}


/* Insert an element befer the element giver by ptr [WARN: In general this is very expensive for an array] */
static TYPE* _insert_before(ch_array_##TYPE##_t* this, TYPE* ptr, TYPE value)
{

    if(unlikely(ptr < this->_array_backing)){
        prTYPEf("ptr supplied is out of range. Too small.\n");
        return NULL;
    }

    /* NB: It's ok to insert before count + 1. This essentially inserts at count which is the last item. */
    if(unlikely(ptr > this->_array_backing + this->_array_backing_count + 1)){
        prTYPEf("ptr supplied is out of range. Too big.\n");
        return NULL;
    }

    if(unlikely(this->_array_backing_count >= this->_array_backing_size)){
        prTYPEf("Array list is full!\n");
        return NULL;

    }

    if(likely(this->_array_backing_count  && ptr <= this->_array_backing + this->_array_backing_count )){


        prTYPEf("ptr:%p[%li], first:%p[%li], last:%p[%li], end:%p:[%li]\n",
                (void*)ptr, ptr - this->first,
                (void*)this->first, this->first - this->first,
                (void*)this->last, this->last - this->first,
                (void*)this->end, this->end - this->first );


        prTYPEf("Moving %lu\n", this->_array_backing + this->_array_backing_count - ptr);

        memmove(ptr + 1,ptr , (this->_array_backing + this->_array_backing_count - ptr) * sizeof(TYPE));
    }
    else{
        prTYPEf("ptr:%p[%li], first:%p[%li], last:%p[%li], end:%p:[%li]\n",
                (void*)ptr, ptr - this->first,
                (void*)this->first, this->first - this->first,
                (void*)this->last, this->last - this->first,
                (void*)this->end, this->end - this->first );

        prTYPEf("Not moving\n");
    }

    *ptr = value;

    if(unlikely(this->_array_backing_count == 0)){
        this->last = this->_array_backing;
        this->first = this->_array_backing;
    }
    else{
        this->last++;
    }

    this->_array_backing_count++;
    this->count++;
    this->end++;

    return ptr;
}

/* Insert an element after the element given by ptr* [WARN: In general this is very expensive for an array] */
static TYPE* _insert_after(ch_array_##TYPE##_t* this, TYPE* ptr, TYPE value)
{
    /*Inserting after is the equivalent to inserting before, the value after the current */
    return _insert_before(this,ptr++,value);
}


/* Put an element at the front of the array values, [WARN: In general this is very expensive for an array] */
static TYPE* _push_front(ch_array_##TYPE##_t* this, TYPE value)
{
    /* Pushing onto the front is equivalent to inserting at the head */
    return _insert_before(this, this->_array_backing, value);
}

/* Put an element at the back of the arary values*/
static TYPE* _push_back(ch_array_##TYPE##_t* this, TYPE value)
{
    /* Pushing onto the end is equivalent to inserting at the tail */
    _insert_before(this, this->end, value);
    return NULL;
}


/*Remove the given ptr [WARN: In general this is very expensive], return an to the next item in the list */
static TYPE*(_remove)(ch_array_##TYPE##_t* this, TYPE* ptr)
{

    if(unlikely(this->first == this->end)){
        prTYPEf("Array list is empty\n");
        return NULL;
    }

    if(unlikely(ptr < this->_array_backing)){
        prTYPEf("ptr supplied is out of range. Too small.\n");
        return NULL;
    }

    if(unlikely(ptr > this->_array_backing + this->_array_backing_count)){
        prTYPEf("ptr supplied is out of range. Too big.\n");
        return NULL;
    }

    //Slow path
    if(unlikely(ptr != this->last)){
/*
        prTYPEf("ptr:%p[%li], first:%p[%li], last:%p[%li], end:%p:[%li]",
                (void*)ptr, ptr - this->first,
                (void*)this->first, this->last - this->first,
                (void*)this->last, this->last - this->first,
                (void*)this->end, this->end - this->first );
*/
        memmove(ptr, ptr + 1, (this->last) - (ptr + 1) );
    }

    this->_array_backing_count--;
    this->count--;


    if(unlikely(this->_array_backing_count == 0)){
        this->last  = this->_array_backing;
        this->first = this->_array_backing;
        this->end   = this->_array_backing;
    }
    else{
        this->last--;
        this->end--;
    }

    return ptr;
}


static void _delete(ch_array_##TYPE##_t* this)
{
    if(this->_array_backing){
        free(this->_array_backing);
    }

    free(this);
}


ch_array_##TYPE##_t* ch_array_##TYPE##_new(ch_word size, ch_word (*cmp)(TYPE lhs, TYPE rhs) )
{

    ch_array_##TYPE##_t* result = (ch_array_##TYPE##_t*)calloc(1,sizeof(ch_array_##TYPE##_t));
    if(!result){
        prTYPEf("Could not allocate memory for new array structure. Giving up\n");
        return NULL;
    }

    result->_array_backing       = calloc(size,sizeof(TYPE));
    if(!result->_array_backing){
        prTYPEf("Could not allocate memory for new array backing. Giving up\n");
        free(result);
        return NULL;
    }

    /*We have memory to play with, now do all the other assignments*/
    result->_array_backing_size  	= size;
    result->_array_backing_count 	= 0;
    result->_cmp                 	= cmp;
    result->first				 	= result->_array_backing;
    result->last				 	= result->_array_backing;
    result->end				     	= result->_array_backing;
    result->size            		= result->_array_backing_size;
    result->count           		= result->_array_backing_count;
    result->resize          		= _resize;
    result->off             		= _off;
    result->next                    = _next;
    result->prev                    = _prev;
    result->forward                 = _forward;
    result->back                    = _back;
    result->find            		= _find;
    result->sort           		 	= _sort;
    result->sort_reverse    		= _sort_reverse;
    result->push_front      		= _push_front;
    result->push_back       		= _push_back;
    result->insert_after    		= _insert_after;
    result->insert_before   		= _insert_before;
    result->remove                  = _remove;
    result->delete          		= _delete;

    return result;
}


